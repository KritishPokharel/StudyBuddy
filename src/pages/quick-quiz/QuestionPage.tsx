import React, { useState, useEffect } from 'react';
import { useNavigate, useParams, useSearchParams } from 'react-router-dom';
import { ArrowRight, X } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { Progress } from '@/components/ui/progress';
import { useAuth } from '@/contexts/AuthContext';
import { api } from '@/lib/api';
import { useToast } from '@/hooks/use-toast';

// Try to load quiz from localStorage (generated by backend)
const loadQuizFromStorage = () => {
  try {
    const stored = localStorage.getItem('currentQuiz');
    if (stored) {
      const quiz = JSON.parse(stored);
      const questions = quiz.questions || [];
      
      // Normalize questions to match expected format
      // Backend returns: { question: "...", options: ["A", "B", "C", "D"], correctAnswer: "A" }
      // Frontend expects: { text: "...", options: [{ id: "a", text: "A" }], correctAnswer: "a" }
      console.log('[QuestionPage] Raw questions from storage:', questions);
      const normalized = questions.map((q: any, idx: number) => {
        // If already in correct format, return as is
        if (q.text && q.options && Array.isArray(q.options) && q.options[0]?.text) {
          console.log('[QuestionPage] Question already in correct format:', q.id);
          return q;
        }
        
        console.log('[QuestionPage] Normalizing question:', q);
        
        // Convert backend format to frontend format
        // Handle cases where text might be in different fields
        let questionText = q.text || q.question || '';
        
        // If questionText is too short (like just "O(n)"), it might be incomplete
        // Check if there's a better field or if we need to construct it
        if (!questionText || questionText.length < 10) {
          // Try to find question in other fields
          questionText = q.question_text || q.questionText || q.text || q.question || '';
          
          // If still too short, log a warning
          if (!questionText || questionText.length < 10) {
            console.warn('[QuestionPage] Question text is very short or missing:', {
              id: q.id,
              text: q.text,
              question: q.question,
              questionText: q.questionText,
              fullQuestion: q
            });
          }
        }
        
        const optionsArray = q.options || [];
        const correctAnswer = q.correctAnswer || '';
        
        // Convert options array to objects with id and text
        const normalizedOptions = optionsArray.map((opt: string | { id: string; text: string }, optIdx: number) => {
          if (typeof opt === 'string') {
            // Convert string option to object
            const optionId = String.fromCharCode(97 + optIdx); // a, b, c, d
            return {
              id: optionId,
              text: opt
            };
          }
          return opt; // Already an object
        });
        
        // Normalize correctAnswer to match option id
        let normalizedCorrectAnswer = correctAnswer;
        if (typeof correctAnswer === 'string' && normalizedOptions.length > 0) {
          // Clean up the correctAnswer string
          const cleanAnswer = correctAnswer.trim();
          
          // Try multiple matching strategies
          // 1. Direct text match
          let match = normalizedOptions.find((opt: any) => 
            opt.text === cleanAnswer || opt.text.trim() === cleanAnswer
          );
          
          // 2. Case-insensitive match
          if (!match) {
            match = normalizedOptions.find((opt: any) => 
              opt.text.toLowerCase() === cleanAnswer.toLowerCase() ||
              opt.text.toLowerCase().trim() === cleanAnswer.toLowerCase()
            );
          }
          
          // 3. Extract letter from "Option A" or "A" format
          if (!match) {
            const letterMatch = cleanAnswer.match(/option\s*([a-d])/i) || cleanAnswer.match(/^([a-d])$/i);
            if (letterMatch) {
              const letter = letterMatch[1].toLowerCase();
              match = normalizedOptions.find((opt: any, idx: number) => 
                String.fromCharCode(97 + idx) === letter
              );
            }
          }
          
          // 4. Match by index if correctAnswer is a number
          if (!match && !isNaN(Number(cleanAnswer))) {
            const idx = parseInt(cleanAnswer) - 1;
            if (idx >= 0 && idx < normalizedOptions.length) {
              match = normalizedOptions[idx];
            }
          }
          
          if (match) {
            normalizedCorrectAnswer = match.id;
          } else {
            // Default to first option if can't match
            console.warn(`[QuestionPage] Could not match correctAnswer "${cleanAnswer}", defaulting to first option`);
            normalizedCorrectAnswer = normalizedOptions[0]?.id || 'a';
          }
        } else if (normalizedOptions.length > 0) {
          // If correctAnswer is not a string, default to first option
          normalizedCorrectAnswer = normalizedOptions[0]?.id || 'a';
        }
        
        return {
          id: q.id || `q${idx + 1}`,
          text: questionText,
          options: normalizedOptions,
          correctAnswer: normalizedCorrectAnswer,
          explanation: q.explanation || q.feedback || '',
          topic: q.topic || '',
          imageUrl: q.imageUrl || null
        };
      });
      console.log('[QuestionPage] Normalized questions:', normalized);
      return normalized;
    }
  } catch (e) {
    console.error('Failed to load quiz:', e);
  }
  return null;
};

// Computer Science questions
const csQuestions = [
  {
    id: '1',
    text: 'What will be the output of the following Python for loop? for i in range(3): print(i)',
    options: [
      { id: 'a', text: '1, 2, 3' },
      { id: 'b', text: '0, 1, 2' },
      { id: 'c', text: '0, 1, 2, 3' },
      { id: 'd', text: '1, 2' },
    ],
    correctAnswer: 'b',
    explanation: 'In Python, range(3) creates a sequence from 0 to 2 (exclusive of 3). The loop iterates through 0, 1, and 2, printing each value.',
    imageUrl: null
  },
  {
    id: '2',
    text: 'Which of the following is NOT a type of loop in most programming languages?',
    options: [
      { id: 'a', text: 'for loop' },
      { id: 'b', text: 'while loop' },
      { id: 'c', text: 'until loop' },
      { id: 'd', text: 'do-while loop' },
    ],
    correctAnswer: 'c',
    explanation: 'Most programming languages have for loops, while loops, and do-while loops. The "until loop" is not a standard loop construct in most mainstream programming languages.',
    imageUrl: null
  },
  {
    id: '3',
    text: 'Which loop is guaranteed to execute at least once in most programming languages?',
    options: [
      { id: 'a', text: 'for loop' },
      { id: 'b', text: 'while loop' },
      { id: 'c', text: 'do-while loop' },
      { id: 'd', text: 'foreach loop' },
    ],
    correctAnswer: 'c',
    explanation: 'A do-while loop always executes its body at least once before checking the condition, unlike for and while loops which check the condition before executing the body.',
    imageUrl: null
  }
];

// Chemistry questions
const chemistryQuestions = [
  {
    id: '1',
    text: 'Which of the following represents a balanced chemical equation for the combustion of methane?',
    options: [
      { id: 'a', text: 'CH₄ + O₂ → CO₂ + H₂O' },
      { id: 'b', text: 'CH₄ + 2O₂ → CO₂ + 2H₂O' },
      { id: 'c', text: 'CH₄ + O₂ → CO₂ + 2H₂O' },
      { id: 'd', text: 'CH₄ + 2O₂ → CO₂ + H₂O' },
    ],
    correctAnswer: 'b',
    explanation: 'The balanced equation is CH₄ + 2O₂ → CO₂ + 2H₂O. This ensures that the number of atoms of each element is the same on both sides of the equation.',
    imageUrl: null
  },
  {
    id: '2',
    text: 'In the reaction 2NaOH + H₂SO₄ → Na₂SO₄ + 2H₂O, how many moles of H₂SO₄ are needed to react with 4 moles of NaOH?',
    options: [
      { id: 'a', text: '1 mole' },
      { id: 'b', text: '2 moles' },
      { id: 'c', text: '4 moles' },
      { id: 'd', text: '8 moles' },
    ],
    correctAnswer: 'b',
    explanation: 'From the balanced equation, 2 moles of NaOH react with 1 mole of H₂SO₄. Therefore, 4 moles of NaOH would require 4 ÷ 2 = 2 moles of H₂SO₄.',
    imageUrl: null
  },
  {
    id: '3',
    text: 'Which of the following is an Arrhenius acid?',
    options: [
      { id: 'a', text: 'NaOH' },
      { id: 'b', text: 'KOH' },
      { id: 'c', text: 'HCl' },
      { id: 'd', text: 'NH₃' },
    ],
    correctAnswer: 'c',
    explanation: 'An Arrhenius acid is a substance that releases H⁺ ions (protons) when dissolved in water. HCl dissociates into H⁺ and Cl⁻ ions in water, making it an Arrhenius acid.',
    imageUrl: null
  }
];

// Physics questions
const physicsQuestions = [
  {
    id: '1',
    text: 'Which of Newton\'s laws states that "for every action, there is an equal and opposite reaction"?',
    options: [
      { id: 'a', text: 'First Law' },
      { id: 'b', text: 'Second Law' },
      { id: 'c', text: 'Third Law' },
      { id: 'd', text: 'Law of Conservation of Energy' },
    ],
    correctAnswer: 'c',
    explanation: 'Newton\'s Third Law states that when one body exerts a force on another, the second body exerts a force equal in magnitude and opposite in direction on the first body.',
    imageUrl: null
  },
  {
    id: '2',
    text: 'What is the work done when a force of 10 N moves an object 5 meters in the direction of the force?',
    options: [
      { id: 'a', text: '2 Joules' },
      { id: 'b', text: '15 Joules' },
      { id: 'c', text: '50 Joules' },
      { id: 'd', text: '100 Joules' },
    ],
    correctAnswer: 'c',
    explanation: 'Work is calculated as W = F × d, where F is force and d is displacement in the direction of the force. So W = 10 N × 5 m = 50 Joules.',
    imageUrl: null
  },
  {
    id: '3',
    text: 'A 2 kg object moving at 4 m/s collides elastically with a stationary 6 kg object. What is the velocity of the 2 kg object after collision?',
    options: [
      { id: 'a', text: '-2 m/s' },
      { id: 'b', text: '0 m/s' },
      { id: 'c', text: '2 m/s' },
      { id: 'd', text: '4 m/s' },
    ],
    correctAnswer: 'a',
    explanation: 'In an elastic collision, both momentum and kinetic energy are conserved. Solving the equations, the 2 kg object rebounds with a velocity of -2 m/s (in the opposite direction).',
    imageUrl: null
  }
];

// DSA questions - All tree questions for Python
const dsaQuestions = [
  {
    id: '1',
    text: 'In Python, what is the most efficient way to check if a binary search tree contains a specific value?',
    options: [
      { id: 'a', text: 'Perform a breadth-first search' },
      { id: 'b', text: 'Perform a post-order traversal' },
      { id: 'c', text: 'Perform a binary search (comparing with current node and going left or right)' },
      { id: 'd', text: 'Check every node using pre-order traversal' },
    ],
    correctAnswer: 'c',
    explanation: 'Since a binary search tree has the property that all values in the left subtree are less than the root and all values in the right subtree are greater than the root, we can perform a binary search. This approach has O(log n) time complexity in a balanced BST, compared to O(n) for traversing all nodes.',
    imageUrl: null,
    topic: 'Trees'
  },
  {
    id: '2',
    text: 'Which Python code correctly checks if a binary tree is a valid Binary Search Tree (BST)?',
    options: [
      { id: 'a', text: 'def is_bst(root): return is_bst_helper(root, float("-inf"), float("inf"))\ndef is_bst_helper(node, min_val, max_val): if not node: return True\nif node.val <= min_val or node.val >= max_val: return False\nreturn is_bst_helper(node.left, min_val, node.val) and is_bst_helper(node.right, node.val, max_val)' },
      { id: 'b', text: 'def is_bst(root): if not root: return True\nif root.left and root.left.val > root.val: return False\nif root.right and root.right.val < root.val: return False\nreturn is_bst(root.left) and is_bst(root.right)' },
      { id: 'c', text: 'def is_bst(root): values = []\ndef inorder(node): if node: inorder(node.left); values.append(node.val); inorder(node.right)\ninorder(root)\nreturn values == sorted(values)' },
      { id: 'd', text: 'def is_bst(root): if not root: return True\nreturn is_bst(root.left) and is_bst(root.right)' },
    ],
    correctAnswer: 'a',
    explanation: 'The correct approach uses a helper function that tracks the valid range for each node as we traverse down the tree. For any node, its value must be greater than the minimum value (from the right branch of ancestors) and less than the maximum value (from the left branch of ancestors). Option B only checks immediate children, not the entire subtree. Option C works but is less efficient. Option D doesn\'t check any values.',
    imageUrl: null,
    topic: 'Trees'
  },
  {
    id: '3',
    text: 'In Python, which method would you use to find the lowest common ancestor (LCA) of two nodes in a binary tree?',
    options: [
      { id: 'a', text: 'def lca(root, p, q): if not root or root == p or root == q: return root\nleft = lca(root.left, p, q)\nright = lca(root.right, p, q)\nif left and right: return root\nreturn left if left else right' },
      { id: 'b', text: 'def lca(root, p, q): if p.val < root.val and q.val < root.val: return lca(root.left, p, q)\nif p.val > root.val and q.val > root.val: return lca(root.right, p, q)\nreturn root' },
      { id: 'c', text: 'def lca(root, p, q): path_p = find_path(root, p)\npath_q = find_path(root, q)\nfor i in range(min(len(path_p), len(path_q))):\n    if path_p[i] != path_q[i]: return path_p[i-1]\nreturn path_p[min(len(path_p), len(path_q))-1]' },
      { id: 'd', text: 'def lca(root, p, q): queue = [root]\nwhile queue:\n    node = queue.pop(0)\n    if contains(node, p) and contains(node, q): return node\n    if node.left: queue.append(node.left)\n    if node.right: queue.append(node.right)\nreturn None' },
    ],
    correctAnswer: 'a',
    explanation: 'Option A is the most efficient recursive solution for finding the lowest common ancestor in a binary tree. It works by traversing the tree bottom-up, returning the node itself if it matches either p or q. When both left and right subtrees return a non-null value, the current node is the LCA. Option B only works for binary search trees, not general binary trees. Options C and D are less efficient implementations.',
    imageUrl: null,
    topic: 'Trees'
  }
];

const QuestionPage = () => {
  const { index } = useParams();
  const [searchParams] = useSearchParams();
  const selectedLibraryItem = searchParams.get('libraryItem') || '1';
  const hasUploadedFiles = searchParams.get('uploadedFiles') === 'true';
  const specificTopic = searchParams.get('topic') || '';
  const quizId = searchParams.get('quizId');
  
  const getQuestions = () => {
    // Fallback to mock questions
    if (hasUploadedFiles) {
      if (specificTopic) {
        return dsaQuestions.filter(q => q.topic === specificTopic);
      }
      return dsaQuestions;
    }
    
    switch (selectedLibraryItem) {
      case '1': return csQuestions;
      case '2': return chemistryQuestions;
      case '3': return physicsQuestions;
      default: return csQuestions;
    }
  };
  
  const getSubjectTitle = () => {
    // Always use the quiz title from the backend - no hardcoded fallbacks
    const stored = localStorage.getItem('currentQuiz');
    if (stored) {
      try {
        const quiz = JSON.parse(stored);
        if (quiz.title) return quiz.title;
      } catch (e) {
        // Ignore parse errors
      }
    }
    
    // If no title found, try to get from URL params or use a generic fallback
    const searchParams = new URLSearchParams(window.location.search);
    const subject = searchParams.get('subject');
    if (subject) {
      return `${subject} Quiz`;
    }
    
    // Last resort: generic fallback
    return 'Quiz';
  };
  
  // Use quiz from localStorage if available, otherwise fallback to mock questions
  const storedQuizQuestions = loadQuizFromStorage();
  const questionsToUse = storedQuizQuestions && storedQuizQuestions.length > 0 ? storedQuizQuestions : getQuestions();
  const questionIndex = parseInt(index || '1') - 1;
  const question = questionsToUse[questionIndex];
  const totalQuestions = questionsToUse.length;
  
  // Debug: Log question data
  useEffect(() => {
    if (question) {
      console.log('[QuestionPage] Current question:', {
        id: question.id,
        text: question.text,
        question: question.question,
        optionsCount: question.options?.length || 0,
        options: question.options,
        correctAnswer: question.correctAnswer
      });
    }
  }, [question]);
  
  // Safety check - if no question found, show error
  if (!question && questionsToUse.length > 0) {
    console.error('Question not found at index:', questionIndex, 'Total questions:', totalQuestions);
  }
  
  const { user } = useAuth();
  const { toast } = useToast();
  const navigate = useNavigate();
  const [selectedOption, setSelectedOption] = useState<string | null>(null);
  const [isAnswered, setIsAnswered] = useState(false);
  // Calculate time based on number of questions: 10 questions = 10 min, 15 = 15 min, 20 = 20 min
  const getInitialTimeLeft = () => {
    const stored = localStorage.getItem('currentQuiz');
    if (stored) {
      try {
        const quiz = JSON.parse(stored);
        const questionCount = quiz.questions?.length || 0;
        // 1 question per minute: 10 questions = 10 minutes = 600 seconds
        return questionCount * 60;
      } catch (e) {
        // Fallback to 10 minutes
        return 600;
      }
    }
    return 600; // Default 10 minutes
  };
  
  const [timeLeft, setTimeLeft] = useState(getInitialTimeLeft());
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [answers, setAnswers] = useState<Array<{question_id: string, selected_answer: string, is_correct: boolean}>>([]);
  const [quizData, setQuizData] = useState<any>(null);
  const [startTime, setStartTime] = useState<number>(Date.now());
  
  useEffect(() => {
    // Load quiz data and set start time
    const loadQuizData = async () => {
      const stored = localStorage.getItem('currentQuiz');
      if (stored) {
        try {
          const quiz = JSON.parse(stored);
          setQuizData(quiz);
          
          // Update timer based on question count: 10 questions = 10 min, 15 = 15 min, 20 = 20 min
          const questionCount = quiz.questions?.length || 0;
          const calculatedTime = questionCount * 60; // 1 question per minute in seconds
          setTimeLeft(calculatedTime);
          
          // Set start time when quiz loads
          const storedStartTime = localStorage.getItem('quizStartTime');
          if (storedStartTime) {
            setStartTime(parseInt(storedStartTime));
          } else {
            const now = Date.now();
            setStartTime(now);
            localStorage.setItem('quizStartTime', now.toString());
          }
        } catch (e) {
          console.error('Failed to load quiz from localStorage:', e);
        }
      } else if (quizId) {
        // If no localStorage data but quizId exists, fetch from backend
        try {
          console.log('[QuestionPage] Fetching quiz from backend:', quizId);
          const quiz = await api.getQuiz(quizId);
          // Normalize questions if needed
          if (quiz.questions) {
            const normalizedQuestions = quiz.questions.map((q: any, idx: number) => {
              // If already in correct format, return as is
              if (q.text && q.options && Array.isArray(q.options) && q.options[0]?.text) {
                return q;
              }
              
              // Convert backend format to frontend format
              const questionText = q.question || q.text || '';
              const optionsArray = q.options || [];
              const correctAnswer = q.correctAnswer || '';
              
              // Convert options array to objects with id and text
              const normalizedOptions = optionsArray.map((opt: string | { id: string; text: string }, optIdx: number) => {
                if (typeof opt === 'string') {
                  const optionId = String.fromCharCode(97 + optIdx); // a, b, c, d
                  return { id: optionId, text: opt };
                }
                return opt;
              });
              
              // Normalize correctAnswer
              let normalizedCorrectAnswer = correctAnswer;
              if (typeof correctAnswer === 'string' && normalizedOptions.length > 0) {
                const cleanAnswer = correctAnswer.trim();
                let match = normalizedOptions.find((opt: any) => 
                  opt.text === cleanAnswer || opt.text.trim() === cleanAnswer
                );
                
                if (!match) {
                  match = normalizedOptions.find((opt: any) => 
                    opt.text.toLowerCase() === cleanAnswer.toLowerCase()
                  );
                }
                
                if (!match) {
                  const letterMatch = cleanAnswer.match(/option\s*([a-d])/i) || cleanAnswer.match(/^([a-d])$/i);
                  if (letterMatch) {
                    const letter = letterMatch[1].toLowerCase();
                    match = normalizedOptions.find((opt: any, idx: number) => 
                      String.fromCharCode(97 + idx) === letter
                    );
                  }
                }
                
                if (match) {
                  normalizedCorrectAnswer = match.id;
                } else {
                  normalizedCorrectAnswer = normalizedOptions[0]?.id || 'a';
                }
              }
              
              return {
                id: q.id || `q${idx + 1}`,
                text: questionText,
                options: normalizedOptions,
                correctAnswer: normalizedCorrectAnswer,
                explanation: q.explanation || q.feedback || '',
                topic: q.topic || '',
                imageUrl: q.imageUrl || null
              };
            });
            quiz.questions = normalizedQuestions;
          }
          
          // Store in localStorage for consistency
          localStorage.setItem('currentQuiz', JSON.stringify(quiz));
          setQuizData(quiz);
          
          // Update timer based on question count: 10 questions = 10 min, 15 = 15 min, 20 = 20 min
          const questionCount = quiz.questions?.length || 0;
          const calculatedTime = questionCount * 60; // 1 question per minute in seconds
          setTimeLeft(calculatedTime);
          
          // Set start time
          const now = Date.now();
          setStartTime(now);
          localStorage.setItem('quizStartTime', now.toString());
        } catch (error) {
          console.error('Failed to fetch quiz from backend:', error);
          toast({
            title: 'Error',
            description: 'Failed to load quiz. Please try again.',
            variant: 'destructive'
          });
        }
      }
    };
    
    loadQuizData();
  }, [quizId, toast]);
  
  useEffect(() => {
    setSelectedOption(null);
    setIsAnswered(false);
    setIsSubmitting(false);
  }, [questionIndex]);
  
  useEffect(() => {
    const timer = setInterval(() => {
      setTimeLeft(prev => {
        if (prev <= 1) {
          clearInterval(timer);
          navigate('/dashboard/quick-quiz/summary');
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
    
    return () => clearInterval(timer);
  }, [navigate]);
  
  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };
  
  const handleSubmitAnswer = () => {
    if (!selectedOption || !question) return;
    
    setIsSubmitting(true);
    setIsAnswered(true);
    
    // Check if answer is correct
    const isCorrect = selectedOption === question.correctAnswer;
    
    // Save answer
    const newAnswer = {
      question_id: question.id,
      selected_answer: selectedOption,
      is_correct: isCorrect
    };
    
    setAnswers(prev => {
      const filtered = prev.filter(a => a.question_id !== question.id);
      return [...filtered, newAnswer];
    });
    
    setTimeout(() => {
      setIsSubmitting(false);
    }, 500);
  };
  
  const handleNextQuestion = async () => {
    if (questionIndex < totalQuestions - 1) {
      navigate(`/dashboard/quick-quiz/question/${questionIndex + 2}?${searchParams.toString()}`);
    } else {
      // Quiz completed - save answers to localStorage first
      localStorage.setItem('quizAnswers', JSON.stringify(answers));
      
      // Save results to backend
      await saveQuizResults();
      
      const quizId = quizData?.quiz_id || searchParams.get('quizId');
      const isRAGQuiz = quizData?.title?.includes('RAG-Based') || quizData?.title?.includes('Comprehensive');
      if (quizId) {
        navigate(`/dashboard/quick-quiz/summary?quizId=${quizId}${isRAGQuiz ? '&ragQuiz=true' : ''}`);
      } else {
        // Include quizId in URL if available
        const quizIdParam = quizData?.quiz_id ? `?quizId=${quizData.quiz_id}${isRAGQuiz ? '&ragQuiz=true' : ''}` : '';
        navigate(`/dashboard/quick-quiz/summary${quizIdParam}`);
      }
    }
  };
  
  const saveQuizResults = async () => {
    if (!user?.id || !quizData) return;
    
    try {
      const correctCount = answers.filter(a => a.is_correct).length;
      const score = Math.round((correctCount / totalQuestions) * 100);
      
      // Calculate time spent - ALWAYS use localStorage quizStartTime for accuracy
      const endTime = Date.now();
      const quizStartTimeStr = localStorage.getItem('quizStartTime');
      const actualStartTime = quizStartTimeStr ? parseInt(quizStartTimeStr) : startTime;
      
      console.log('[QuestionPage] Calculating time spent:', {
        endTime,
        actualStartTime,
        stateStartTime: startTime,
        localStorageStartTime: quizStartTimeStr,
        difference: endTime - actualStartTime
      });
      
      const timeSpentMs = endTime - actualStartTime;
      const timeSpentSeconds = Math.floor(timeSpentMs / 1000);
      const minutes = Math.floor(timeSpentSeconds / 60);
      const seconds = timeSpentSeconds % 60;
      const timeSpentFormatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      console.log('[QuestionPage] Time spent calculated:', {
        timeSpentFormatted,
        timeSpentSeconds,
        minutes,
        seconds
      });
      
      // Identify weak topics (topics where user got questions wrong)
      const wrongAnswers = answers.filter(a => !a.is_correct);
      const weakTopics: string[] = [];
      
      wrongAnswers.forEach(answer => {
        const q = questionsToUse.find((q: any) => q.id === answer.question_id);
        if (q && q.topic && !weakTopics.includes(q.topic)) {
          weakTopics.push(q.topic);
        }
      });
      
      // Save weak topics and time spent to localStorage for recommendations
      if (weakTopics.length > 0) {
        localStorage.setItem('quizWeakTopics', JSON.stringify(weakTopics));
      }
      localStorage.setItem('quizTimeSpent', timeSpentFormatted);
      localStorage.setItem('quizScore', score.toString());
      
      // Calculate counts
      const wrongCount = totalQuestions - correctCount;
      
      await api.saveQuizResult({
        user_id: user.id,
        quiz_id: quizData.quiz_id,
        score: score,
        answers: answers,
        weak_topics: weakTopics,
        time_spent: timeSpentSeconds, // Save in seconds
        quiz_title: quizData.title,
        quiz_topics: quizData.questions?.map((q: any) => q.topic).filter(Boolean) || [],
        correct_count: correctCount,
        wrong_count: wrongCount,
        total_questions: totalQuestions
      });
      
      console.log(`Quiz results saved. Score: ${score}%, Time: ${timeSpentFormatted}, Weak topics: ${weakTopics.join(', ')}`);
    } catch (error) {
      console.error('Failed to save quiz results:', error);
      // Don't show error - quiz can still work without backend save
    }
    // Note: Don't remove quizStartTime here - let SummaryPage use it for accurate time calculation
    // It will be cleaned up after the summary is displayed
  };
  
  const handleExit = () => {
    navigate('/dashboard');
  };
  
  // Show error if question not found
  if (!question) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-3xl mx-auto">
          <Card>
            <CardContent className="p-12 text-center">
              <h2 className="text-xl font-semibold mb-4">Question Not Found</h2>
              <p className="text-studyneutral-300 mb-6">
                Unable to load the question. Please try generating the quiz again.
              </p>
              <Button onClick={handleExit} variant="outline">
                Back to Dashboard
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>
    );
  }
  
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="max-w-3xl mx-auto">
        <div className="flex justify-between items-center mb-6">
          <div className="flex items-center gap-4">
            <Button
              variant="outline"
              size="icon"
              onClick={handleExit}
            >
              <X className="h-4 w-4" />
            </Button>
            <h1 className="text-xl font-semibold">{getSubjectTitle()}</h1>
          </div>
          
          <div className="flex items-center gap-2">
            <div className="h-2 w-2 rounded-full animate-pulse bg-red-500"></div>
            <span className="font-medium">{formatTime(timeLeft)}</span>
          </div>
        </div>
        
        <div className="mb-6">
          <div className="flex justify-between text-sm mb-2">
            <span>Question {questionIndex + 1} of {totalQuestions}</span>
            <span>{Math.round(((questionIndex + 1) / totalQuestions) * 100)}%</span>
          </div>
          <Progress value={((questionIndex + 1) / totalQuestions) * 100} className="h-2" />
        </div>
        
        <Card className="mb-6">
          <CardContent className="p-6">
            <h2 className="text-lg font-medium mb-4">
              {(() => {
                const questionText = question.text || question.question || question.questionText || '';
                // If question text is suspiciously short (like just "O(n)"), show a warning
                if (questionText && questionText.length < 15 && !questionText.includes('?')) {
                  console.warn('[QuestionPage] Question text appears incomplete:', questionText);
                  return questionText || 'Question text is missing. Please refresh the page.';
                }
                return questionText || 'Question';
              })()}
            </h2>
            
            {question.imageUrl && (
              <div className="mb-4 rounded-lg overflow-hidden">
                <img 
                  src={question.imageUrl} 
                  alt="Question visual" 
                  className="w-full object-cover"
                />
              </div>
            )}
            
            <RadioGroup 
              value={selectedOption || ''} 
              onValueChange={setSelectedOption}
              className="space-y-3"
              disabled={isAnswered}
            >
              {question.options.map(option => (
                <div 
                  key={option.id}
                  className={`rounded-lg border p-3 transition-colors ${
                    isAnswered 
                      ? option.id === question.correctAnswer
                        ? 'border-green-500 bg-green-50'
                        : selectedOption === option.id
                          ? 'border-red-500 bg-red-50'
                          : ''
                      : selectedOption === option.id
                        ? 'border-studypurple-400 bg-studypurple-100/50'
                        : 'hover:border-studypurple-200'
                  }`}
                >
                  <div className="flex items-center">
                    <RadioGroupItem value={option.id} id={`option-${option.id}`} />
                    <Label 
                      htmlFor={`option-${option.id}`} 
                      className="ml-2 font-medium cursor-pointer"
                    >
                      {option.text}
                    </Label>
                  </div>
                </div>
              ))}
            </RadioGroup>
          </CardContent>
        </Card>
        
        {isAnswered && (
          <Card className="mb-6 border-l-4 border-l-green-500 animate-fade-in">
            <CardContent className="p-4">
              <h3 className="font-semibold text-green-600 mb-1">
                {selectedOption === question.correctAnswer 
                  ? 'Correct!' 
                  : 'Incorrect'}
              </h3>
              <p>{question.explanation}</p>
            </CardContent>
          </Card>
        )}
        
        <div className="flex justify-end">
          {!isAnswered ? (
            <Button 
              onClick={handleSubmitAnswer} 
              disabled={!selectedOption || isSubmitting}
              className="bg-gradient-to-r from-studypurple-400 to-studypurple-300 hover:opacity-90"
            >
              {isSubmitting ? 'Submitting...' : 'Submit Answer'}
            </Button>
          ) : (
            <Button 
              onClick={handleNextQuestion}
              className="bg-gradient-to-r from-studypurple-400 to-studypurple-300 hover:opacity-90"
            >
              <div className="flex items-center gap-2">
                {questionIndex < totalQuestions - 1 ? 'Next Question' : 'View Summary'} <ArrowRight className="h-4 w-4" />
              </div>
            </Button>
          )}
        </div>
      </div>
    </div>
  );
};

export default QuestionPage;
